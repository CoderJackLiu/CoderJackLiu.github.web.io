---
title: 【C++】八股文(一)
author: CoderJackLiu
date: 2022-07-01 01:00:00 +0800
categories: [C++]
tags: [C++，面试]
pin: false
---



**1.引用和指针的区别？**

```c++
int m; 
int &n = m; 
```

n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。

所以 n 既不是m的拷贝，也不是指向 m 的指针，其实n就是 m 它自己。

**2.引用规则？**

* 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）
* 不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。
* 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

**3.函数的参数和返回值的传递方式？**

值传递，引用传递，指针传递

**4.引用传递和指针传递的区别？**

* 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；

* 引用传递：形参在函数体内值发生变化，会影响实参的值；
* 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；

​	指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。引用传递则不能引用初始化时给定的变量；

**5.互相引用怎么办？**

​	前向声明

**6.常量指针和指针常量**

const int a;     //指的是a是一个常量，不允许修改。

const int *a;    //a指针所指向的内存里的值不变，即（*a）不变

int const *a;    //同const int *a;

int *const a;    //a指针所指向的内存地址不变，即a不变

const int *const a;   //都不变，即（*a）不变，a也不变

**7.使用指针需要注意什么？**

* 定义指针时，先初始化为NULL。
* 用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。
* 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
* 避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作
* 动态内存的申请与释放必须配对，防止内存泄漏
* 用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”

**8.new和malloc的区别，各自底层实现原理**

* new是操作符，而malloc是函数。
* new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
* malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
* new可以被重载；malloc不行
* new分配内存更直接和安全。
* new发生错误抛出异常，malloc返回null

**9.操作符**

​	操作符可以分为：算术操作符、移位操作符、位操作符、赋值操作符、单目操作符、关系操作符、逻辑操作符、条件操作符、逗号表达式、下标引用函数调用和结构成员操作符等

**10.define宏定义和const的区别**

* 处理阶段：define是在编译的**预处理**阶段起作用，而const是在编译、运行的时候起作用；
* 安全性：
  * define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错；
  * const常量有数据类型，编译器可以对其进行类型安全检查
* 内存占用
  * define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表
  * 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。



下一篇：[]

---

​			"Time after time have given me new courage to face life cheerfully, have been Kindness, *Beauty, and Truth.* "   ---Albert Einstein

---

